---
title: A simplicidade do tRPC com a robustez do Next.js
summary: Uma combina√ß√£o para construir APIs `end-to-end type-safety`
# banner: ./trpc+nextjs.jpeg
# tags:
# - ReactJs
# - JavaScript
# - TypeScript
# - NextJs
# - tRPC
type: 'BlogPost'
publishedAt: 2023-01-02
---

## O que √© tRPC?
Como est√° na pr√≥pria documenta√ß√£o: tRPC permite voc√™ construir APIs totalmente typesafe.
Como ele √© end-to-end type-safety, voc√™ √© capaz de capturar erros entre o seu front e back-end durante a compila√ß√£o ao inv√©s de ser no tempo de execu√ß√£o. E como voc√™ estar√° declarando os tipos e n√£o importando o c√≥digo do servidor seu c√≥digo final ficar√° pequeno e r√°pido.

## Instalando
Primeiro de tudo rode o `create-next-app` para iniciar o seu projeto next.
```bash
npx create-next-app@latest --typescript
```
Utilizei a flag `--typescript` para ter certeza que o nosso projeto ser√° em TS. Marque "N√£o" para o ESLint, Tailwindcss e o app directory (por ainda ser experimental o tRPC ainda n√£o d√° suporte para tal) pois n√£o √© nosso foco aqui, entretanto marquei como "Sim" o src directory.
 
Instalar o tRPC √© bem direto e f√°cil. Tem alguns pacotes que precisamos instalar juntamente dele.
```bash
npm install @trpc/server @trpc/client @trpc/react-query @trpc/next @tanstack/react-query zod
```
Vale dizer que o tRPC √© constru√≠do em cima do `react-query` que √© um pacote para realizar chamadas, cache e controle de data sem precisar mexer em nenhum estado global.
Tamb√©m iremos utilizar o `zod` para nos ajudar com nossos schema e validadores de input.

A pr√≥xima coisa que precisamos √© garantir que o modo strict do node est√° habilitado em nosso `tsconfig.json`
```json
{
	// ‚Ä¶
	‚ÄúcompilerOptions‚Äù: {
		// ‚Ä¶
		‚Äústrict‚Äù: true
	}
}
```
Isso n√£o √© especificamente para o tRPC, entretanto na documenta√ß√£o eles indicam, mas sim para que o `zod` funcione corretamente.


## Criando nosso servidor
```
nextjs-trpc/
	‚îî‚îÄ‚îÄ src/
		‚îî‚îÄ‚îÄ server/
			‚îú‚îÄ‚îÄ api/
			‚îÇ	‚îú‚îÄ‚îÄ routers/
			‚îÇ 	‚îÇ	‚îî‚îÄ‚îÄ example.ts
			‚îÇ	‚îú‚îÄ‚îÄ schemas/
			‚îÇ	‚îÇ	‚îî‚îÄ‚îÄ example.ts
			‚îÇ	‚îú‚îÄ‚îÄ root.ts
			‚îÇ	‚îî‚îÄ‚îÄ trpc.ts
			‚îî‚îÄ‚îÄ utils/
				‚îî‚îÄ‚îÄ api.ts
```
Toda nossa l√≥gica de servidor ir√° ficar dentro da pasta `api`, ela ir√° conter nosso contexto do tRPC, rotas e nossas rotas API. Sim, essa estrutura √© bem similar a que o [T3App]([https://create.t3.gg/](https://create.t3.gg/)) utiliza.

Uma coisa que precisamos notar √© que o nosso servidor ser√° implantado como um rota API do Next.js. Esse c√≥digo √© enviado como um pacote do lado do servidor e n√£o ir√° impactar no tamanho do pacote do lado do cliente. Que delicinha...

Voc√™ pode ler mais sobre as rotas API do Next.js na [Documenta√ß√£o do Next.js](https://nextjs.org/docs/api-routes/introduction).

## Iniciando o tRPC
Para iniciar precisamos definir a base do nosso servidor em tRPC, para isso iremos editar o arquivo `nextjs-trpc\src\server\api\trpc.ts`
```ts
import { initTRPC } from '@trpc/server'

const t = initTRPC.context().create()

export const createTRPCRouter = t.router
export const procedure = t.procedure
```
Bem simples n√©? O `createTRPCRouter` ser√° quem ir√° controlar nossas rotas, j√° o `procedure` quem ir√° definir nossa rota em si. √â bom dizer que nesse momento √© onde a gente pode tamb√©m controlar nossas sess√µes e assim criar rotas protegidas por login, mas isso fica para um pr√≥ximo papo, vamos focar no simples.

## Roteamento
No passo anterior a gente iniciou o nosso tRPC, agora podemos come√ßar a olhar para nosso roteamento no arquivo `nextjs-trpcsrc\server\api\root.ts`.
```ts
import { createTRPCRouter } from '@/server/api/trpc'

export const appRouter = createTRPCRouter({})  
export type AppRouter = typeof appRouter
```
Toda a magia aqui fica por conta do `appRouter` que nada mais √© que a fun√ß√£o que criamos anteriormente e quem ir√° receber um objeto de rotas nomeadas.

## Rotas
Vamos criar nossa primeira rota? Vamos criar ela no nosso arquivo `nextjs-trpc\src\server\api\routers\example.ts`.
```ts
import { createTRPCRouter, procedure } from '@/server/api/trpc'

export const exampleRouter = createTRPCRouter({
	hello: procedure.query(() => ({
		greeting: 'Hello, how are you doing?'
	}))
})
```
Aqui a gente novamente usou o `createTRPCRouter` que √© quem envelopa nossas rotas e o `procedure` quem de fato ir√° declarar a nossa rota. Ent√£o temos uma rota `hello` que ir√° responder com um objeto `{ greeting: 'Hello, how are you doing?' }`

Mas ainda a nossa rota n√£o est√° dentro do nosso servidor, para isso precisamos revisitar o nosso arquivo `nextjs-trpcsrc\server\api\root.ts` e definir ela
```ts
...
import { exampleRouter } from '@/server/api/routers/example'

export const appRouter = createTRPCRouter({
	example: exampleRouter
})
```
Agora sim temos o que seria nossa rota `/example/hello`.

## Next.js API
Depois de criar tudo que precisamos a n√≠vel de server-side, precisamos implementar tudo isso no Next.js.
Primeiro implementar as rotas. Lembra que disse que o tRPC iria utilizar as rotas API do Next.js? Ent√£o vamos l√°. Vamos criar o arquivo `pages/api/trpc/[trpc].ts`
```ts
import { createNextApiHandler } from '@trpc/server/adapters/next'

import { appRouter } from '@/server/api/root'

export default createNextApiHandler({
	router: appRouter,
	createContext: () => ({}),
})
```
Aqui a gente est√° passando para o adaptador do tRPC que converte nossas rotas para a API de rotas do Next.js.

## Next.js Contexto
Agora a gente precisa envolver nossa aplica√ß√£o com o tRPC. Mas podem perguntar "se a gente criou rotas API porque precisamos de envolver o tRPC, n√£o seria s√≥ 'bater' no nosso endpoint?", a resposta poderia ser um "sim", inclusive podemos acessar essa API em outros servi√ßos, mas se lembra que eu disse que o tRPC usa por baixo dos panos o `react-query`? Pois ent√£o, a gente ir√° envolver exatamente para ter todas as funcionalidades desta ferramenta, al√©m de fazer as chamadas API de uma maneira muito mais elegante que veremos em j√° j√°.

Vamos criar o que seria o nosso "provider" do tRPC em `nextjs-trpc\src\utils\api.ts`
```ts
import { createTRPCNext } from '@trpc/next'
import { httpBatchLink } from '@trpc/client'

import { AppRouter } from '@/server/api/root'

const getBaseUrl = () => {
	if (typeof window !== 'undefined') return '' // browser should use relative url
	
	if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}` // SSR should use vercel url

	return `http://localhost:${process.env.PORT ?? 3000}` // dev SSR should use localhost
}

export const api = createTRPCNext<AppRouter>({
	config() {
		return {
			links: [
				httpBatchLink({
					url: `${getBaseUrl()}/api/trpc`,
				})
			]
		}
	}
})
```
Agora vamos envolver toda nossa aplica√ß√£o com o tRPC editando `nextjs-trpc\src\pages\_app.tsx`
```ts
...
import { api } from '@/utils/api'

function App({ Component, pageProps }: AppProps) {
	...
}

export default api.withTRPC(App)
```
Pronto! Nesse momento voc√™ j√° fez uma configura√ß√£o b√°sica para utilizar o tRPC com Next.js.

## Fazendo uma chamada API
Vamos finalmente ver o que a gente fez at√© agora de fato rodando?
Vamos testar criando uma nova rota, eu chamei ela de trpc `nextjs-trpc\src\pages\trpc.tsx`.
```ts	
export default function TRPCPage() {
	return <></>
}
```
Provavelmente agora voc√™ imagina que a gente iria fazer algo do tipo:
```ts
const handleFetchData = async () => await fetch('/api/trpc/example/hello')
```
Mas n√£o! Eu disse que seria uma maneira muito mais elegante, e ainda utilizando todo o poder do `react-query`
```ts
import { api } from "@/utils/api"

export default function TRPCPage() {
	const { data } = api.example.hello.useQuery()
	console.log("üöÄ ~ file: trpc.tsx:5 ~ TRPCPage ~ data:", data)
	
	return <></>
}
```
Que coisa linda n√©?! Como eu disse, muito mais elegante e com todo o poder do `react-query`. Inclusive aconselho dar uma lida na documenta√ß√£o deles, poder√° ajudar.

## E o `zod`?
Eu n√£o esqueci do `zod` t√£o pouco da nossa pasta `schemas` da nossa estrutura de pastas l√° do come√ßo.

Digamos que a gente queria receber algum valor na nossa rota `/example/hello`, como por exemplo eu envie o par√¢metro `name` √© ele retorne aquela mesma mensagem usando o `name`. Vamos l√°!
No nosso arquivo `nextjs-trpc\src\server\api\schemas\example.ts`
```ts
import { z } from 'zod'

export const HelloInputSchema = z.object({
	name: z.string()
})
```
A gente acabou de definir um `input` que √© um objeto que recebe um par√¢metro `name` do tipo `string`, molezinha n√©? Vamos usar ele?
Vamos at√© onde est√° a nossa rota hello `nextjs-trpc\src\server\api\routers\example.ts`
```ts
...
import { HelloInputSchema } from '@/server/api/schemas/example'

...
hello: procedure.input(HelloInputSchema).query(({ input }) => ({
	greeting: `Hello, how are you doing, ${input.name}?`
}))
...
```
Agora antes de chamar o query, a gente utilizou o `input` e passou para ele o que input que definimos antes, e automaticamente a fun√ß√£o `query` recebe por par√¢metro ele √© totalmente tipado.
Mas agora a gente precisa ir at√© onde a gente utilizou essa rota para passar a usar esse par√¢metro.
```ts
const { data } = api.example.hello.useQuery({ name: 'teka' })
```
E quando voc√™ for escrevendo ver√° que o TS ir√° reclamar e indicar quais par√¢metros precisa, exatamente pelo tRPC ser end-to-end e typesafe!

Feito isso a gente acabou de configurar do zero o tRPC da forma mais b√°sica, entretanto mesmo a gente tendo feito o b√°sico ele tr√°s muita simplicidade e agilidade no nosso desenvolvimento.