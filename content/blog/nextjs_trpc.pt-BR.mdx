---
title: A simplicidade do tRPC com a robustez do Next.js
summary: Uma combina√ß√£o para construir APIs `end-to-end type-safe`
# banner: ./trpc+nextjs.jpeg
# tags:
# - ReactJs
# - JavaScript
# - TypeScript
# - NextJs
# - tRPC
type: 'BlogPost'
publishedAt: 2023-01-02
---

Neste artigo, apresento como utilizar o tRPC (transport RPC) e o Next.js em conjunto para construir APIs end-to-end type-safe.

## O que seria "end-to-end type-safe"
"End-to-end type-safe" √© uma abordagem que visa ter uma √∫nica fonte de tipagens em todas as camadas da aplica√ß√£o, desde o back-end at√© o front-end. Isso traz mais seguran√ßa e confiabilidade em rela√ß√£o aos dados manipulados pela aplica√ß√£o. Com essa abordagem, os erros comuns que podem ocorrer quando se lida com dados n√£o tipados em diferentes camadas da aplica√ß√£o s√£o evitados, como inconsist√™ncias nos tipos de dados, valores nulos ou indefinidos, entre outros. Idealmente, essa abordagem deve ocorrer de maneira autom√°tica quando um esquema √© modificado, trazendo maior facilidade e agilidade no desenvolvimento.

## O que √© tRPC?
Segundo a documenta√ß√£o, tRPC permite a constru√ß√£o de APIs totalmente type-safe. Por ser end-to-end type-safe, √© poss√≠vel capturar erros entre o front-end e back-end durante a compila√ß√£o em vez de durante a execu√ß√£o. Al√©m disso, por declarar tipos e n√£o importar o c√≥digo do servidor, o c√≥digo final fica pequeno e r√°pido.

## Instalando
Para come√ßar, inicie o seu projeto Next.js com TypeScript executando o seguinte comando:
```bash
npx create-next-app@latest --typescript
```
Marque "N√£o" para o ESLint, Tailwindcss e o diret√≥rio da aplica√ß√£o, j√° que o tRPC ainda n√£o oferece suporte para este √∫ltimo. Marque "Sim" para a pasta src.

Em seguida, instale o tRPC e seus pacotes associados com o seguinte comando:
```bash
npm install @trpc/server @trpc/client @trpc/react-query @trpc/next @tanstack/react-query zod
```
O tRPC √© constru√≠do em cima do `react-query`, um pacote que permite realizar chamadas, cache e controle de dados sem precisar mexer em nenhum estado global. Tamb√©m iremos utilizar o `zod` para nos ajudar com nossos esquemas e validadores de entrada.

Certifique-se de habilitar o modo `strict` do Node em seu `tsconfig.json` para que o zod funcione corretamente:
```json
{
	// ‚Ä¶
	‚ÄúcompilerOptions‚Äù: {
		// ‚Ä¶
		‚Äústrict‚Äù: true
	}
}
```

## Criando nosso servidor
```
nextjs-trpc/
	‚îî‚îÄ‚îÄ src/
		‚îî‚îÄ‚îÄ server/
			‚îú‚îÄ‚îÄ api/
			‚îÇ	‚îú‚îÄ‚îÄ routers/
			‚îÇ 	‚îÇ	‚îî‚îÄ‚îÄ example.ts
			‚îÇ	‚îú‚îÄ‚îÄ schemas/
			‚îÇ	‚îÇ	‚îî‚îÄ‚îÄ example.ts
			‚îÇ	‚îú‚îÄ‚îÄ root.ts
			‚îÇ	‚îî‚îÄ‚îÄ trpc.ts
			‚îî‚îÄ‚îÄ utils/
				‚îî‚îÄ‚îÄ api.ts
```
A estrutura de arquivos para nosso servidor ir√° ficar dentro da pasta server, que conter√° nosso contexto do tRPC, rotas e nossas rotas API. Essa estrutura √© bem similar √† utilizada pelo <ExternalLink href="https://create.t3.gg/">T3App</ExternalLink>.

√â importante falar que nosso servidor ser√° implantado como uma rota API do Next.js. Esse c√≥digo √© enviado como um pacote do lado do servidor e n√£o ir√° impactar no tamanho do pacote do lado do cliente.

Para mais informa√ß√µes sobre as rotas API do Next.js, consulte a <ExternalLink href="https://nextjs.org/docs/api-routes/introduction">documenta√ß√£o</ExternalLink>.

## Iniciando o tRPC
Para iniciar, precisamos definir a base do nosso servidor em tRPC, editando o arquivo `nextjs-trpc\src\server\api\trpc.ts` da seguinte maneira:
```ts
import { initTRPC } from '@trpc/server'

const t = initTRPC.context().create()

export const createTRPCRouter = t.router
export const procedure = t.procedure
```
Aqui, createTRPCRouter ser√° respons√°vel pelo controle das rotas, enquanto procedure ir√° definir a pr√≥pria rota. √â importante destacar que √© nesse momento que podemos controlar nossas sess√µes e criar rotas protegidas por login, mas isso fica para outro momento.

## Roteamento
No passo anterior, iniciamos o tRPC. Agora, podemos come√ßar a lidar com nosso roteamento, editando o arquivo `nextjs-trpc\src\server\api\root.ts`:
```ts
import { createTRPCRouter } from '@/server/api/trpc'

export const appRouter = createTRPCRouter({})  
export type AppRouter = typeof appRouter
```
Toda a magia aqui fica por conta do `appRouter`, que √© a fun√ß√£o que criamos anteriormente e que ir√° receber um objeto de rotas nomeadas.

## Rotas
Vamos criar nossa primeira rota? Para isso, abra o arquivo `nextjs-trpc\src\server\api\routers\example.ts` e adicione o seguinte c√≥digo:
```ts
import { createTRPCRouter, procedure } from '@/server/api/trpc'

export const exampleRouter = createTRPCRouter({
	hello: procedure.query(() => ({
		greeting: 'Hello, how are you doing?'
	}))
})
```
O c√≥digo acima cria uma rota chamada hello, que responde com um objeto `{ greeting: 'Hello, how are you doing?' }`. Mas ainda n√£o adicionamos essa rota ao nosso servidor. Para fazer isso, precisamos definir a rota no arquivo `nextjs-trpc/src/server/api/root.ts`. Adicione o seguinte c√≥digo:
```ts
...
import { exampleRouter } from '@/server/api/routers/example'

export const appRouter = createTRPCRouter({
	example: exampleRouter
})
```
Com isso, o que seria a nossa rota `/example/hello` est√° pronta para ser usada.

## Next.js API
Ap√≥s criar tudo o que precisamos no servidor, precisamos implementar tudo isso no Next.js. Primeiro, crie o arquivo pages/api/trpc/[trpc].ts:
```ts
import { createNextApiHandler } from '@trpc/server/adapters/next'

import { appRouter } from '@/server/api/root'

export default createNextApiHandler({
	router: appRouter,
	createContext: () => ({}),
})
```
Aqui, utilizamos o adaptador do tRPC, que converte nossas rotas para a API de rotas do Next.js.

## Contexto do Next.js
Agora precisamos envolver nossa aplica√ß√£o com o tRPC. Embora possamos acessar a nossa API por meio do endpoint `/api/trpc/...` sem fazer isso, vamos fazer isso para ter acesso a todas as funcionalidades do `react-query` al√©m de fazer sentido em usar o tRPC. Para isso, crie um arquivo chamado `nextjs-trpc/src/utils/api.ts` e adicione o seguinte c√≥digo:

Primeiro, crie o o que seria nosso "provider" do tRPC em `nextjs-trpc\src\utils\api.ts`:
```ts
import { createTRPCNext } from '@trpc/next'
import { httpBatchLink } from '@trpc/client'

import { AppRouter } from '@/server/api/root'

const getBaseUrl = () => {
	if (typeof window !== 'undefined') return '' // browser should use relative url
	
	if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}` // SSR should use vercel url

	return `http://localhost:${process.env.PORT ?? 3000}` // dev SSR should use localhost
}

export const api = createTRPCNext<AppRouter>({
	config() {
		return {
			links: [
				httpBatchLink({
					url: `${getBaseUrl()}/api/trpc`,
				})
			]
		}
	}
})
```
Agora, envolvemos nossa aplica√ß√£o com o tRPC editando `nextjs-trpc\src\pages\_app.tsx`
```ts
...
import { api } from '@/utils/api'

function App({ Component, pageProps }: AppProps) {
	...
}

export default api.withTRPC(App)
```
Pronto! Agora a configura√ß√£o b√°sica do tRPC com Next.js est√° pronta para ser usada.

## Fazendo uma chamada API
Vamos testar se a configura√ß√£o do tRPC est√° funcionando criando uma nova rota em `nextjs-trpc/src/pages/trpc.tsx`:
```ts	
export default function TRPCPage() {
	return <></>
}
```
Provavelmente voc√™ imagina que a gente iria fazer algo como:
```ts
const handleFetchData = async () => await fetch('/api/trpc/example/hello')
```
Mas n√£o! Usaremos uma maneira mais elegante, ainda utilizando todo o poder do react-query:
```ts
import { api } from "@/utils/api"

export default function TRPCPage() {
	const { data } = api.example.hello.useQuery()
	console.log("üöÄ ~ file: trpc.tsx:5 ~ TRPCPage ~ data:", data)
	
	return <></>
}
```
Como eu disse, muito mais elegante e com todo o poder do react-query. Aconselho, inclusive, dar uma lida na documenta√ß√£o deles para mais informa√ß√µes.

## E o zod?
N√£o esqueci do `zod` ou da nossa pasta `schemas` da estrutura de pastas que definimos l√° no come√ßo.

Digamos que queiramos receber algum valor na nossa rota `/example/hello`, como o par√¢metro `name`, para que retorne aquela mesma mensagem usando este parametro.Para isso, vamos definir um esquema de entrada em nosso arquivo `nextjs-trpc\src\server\api\schemas\example.ts` da seguinte forma:
```ts
import { z } from 'zod'

export const HelloInputSchema = z.object({
	name: z.string()
})
```
Aqui, acabamos de definir um esquema de entrada que √© um objeto que recebe um par√¢metro `name` do tipo string. Agora, vamos utiliz√°-lo na nossa rota `hello` no arquivo `nextjs-trpc\src\server\api\routers\example.ts`:
```ts
...
import { HelloInputSchema } from '@/server/api/schemas/example'

...
hello: procedure.input(HelloInputSchema).query(({ input }) => ({
	greeting: `Hello, how are you doing, ${input.name}?`
}))
...
```
Antes de chamar a fun√ß√£o query, usamos o input e passamos para ele o esquema de entrada que definimos anteriormente. Isso permite que a fun√ß√£o query seja totalmente tipada. Agora, precisamos atualizar onde usamos essa rota para come√ßar a passar o par√¢metro name, conforme o exemplo abaixo:
```ts
const { data } = api.example.hello.useQuery({ name: 'teka' })
```

Ap√≥s concluir essas etapas, configuramos o tRPC do zero em sua forma mais b√°sica. Apesar disso, mesmo com essa configura√ß√£o m√≠nima, o tRPC proporciona uma grande facilidade e agilidade no desenvolvimento.