---
title: Evitando useEffect com callback refs
summary: Intera√ß√£o com um elemento DOM n√£o precisa necessariamente do useEffect
# banner: ./callback.jpeg
# tags:
#   - ReactJs
#   - JavaScript
#   - TypeScript
type: 'BlogPost'
publishedAt: 2023-01-02
---

> Este artigo √© uma tradu√ß√£o de [Avoiding useEffect with callback refs](https://tkdodo.eu/blog/avoiding-use-effect-with-callback-refs)
>
> Originalmente escrito em ingl√™s por [@TkDodo](https://github.com/TkDodo)

---

**Obs: Este artigo assume que voc√™ tenha um entendimento b√°sico do que s√£o _refs_ no React.**

Apesar de os refs serem mut√°veis aonde teoricamente podemos salvar valores arbitr√°rios, eles s√£o frequentemente mais usados para ter acesso a um n√≥ do DOM:

```jsx
const ref = React.useRef(null)

return <input ref={ref} defaultValue="Hello world" />
```

`ref` √© uma propriedade reservada embutida nos primitivos aonde o React ir√° salvar o n√≥ do DOM depois de renderizado. Ele ser√° definido de volta para _null_ quando o componente for desmontado.

## Interagindo com refs

Para a maioria das intera√ß√µes, voc√™ n√£o precisa acessar o elemento subjacente, porque o React lidar√° com as atualiza√ß√µes para n√≥s automaticamente. Um bom exemplo √© aonde voc√™ pode precisar de um ref √© gerenciar o foco.

H√° um [bom RFC](https://github.com/devongovett/rfcs-1/blob/patch-1/text/2019-focus-management.md) do [Devon Govett](https://twitter.com/devongovett) que prop√µe adicionar um Gerenciador de Foco ao rect-dom, mas agora n√£o h√° nada no React que n√≥s ajude com isso.

### Foco com um effect

Ent√£o, agora, como voc√™, focaria um elemento de input depois de renderizado? (Eu sei [autofocus](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autofocus) existe, isto √© um exemplo. Se isso lhe incomoda imagino que voc√™ gistaria de animar o n√≥.)

Bom, a maioria dos c√≥digos que eu vi tenta fazer isso:

```jsx
const ref = React.useRef(null)

React.useEffect(() => {
  ref.current?.focus()
}, [])

return <input ref={ref} defaultValue="Hello world" />
```

Isso √© a principio bom e n√£o viola nenhuma regra. O array de depend√™ncias vazios √© ok porque a √∫nica coisa usada dentro √© o ref que √© est√°vel. O linter n√£o ir√° reclamar de adicionar ao array de dependencia, e o ref tamb√©m n√£o ser√° lido durante a redenriza√ß√£o (o que pode ser problem√°tico com recursos simultaneos do React)

O effect ser√° executado uma vez "na montagem" ([duas vezes em strict mode](https://pt-br.reactjs.org/docs/strict-mode.html#ensuring-reusable-state)). A essa altura React j√° preencheu o ref com o n√≥ do DOM ent√£o podemos dar foco nele.

Sim est√° _n√£o_ √© o melhor maneira de se fazer isso e tem algumas ressalvas em algumas situa√ß√µes mais avan√ßadas.

Especificamente ele assume que o ref ser√° "preenchido" quando o effect for executado. Se n√£o estiver dispon√≠vel, por ex. quando voc√™ passa o ref para um componente customizado que ir√° adiar a renderiza√ß√£o ou somente mostrar o input depois de alguma outra intera√ß√£o do usu√°rio, o conte√∫do do ref continuar√° _null_ e quando o effect ser executado nada ser√° focado:

```jsx
function App() {
  const ref = React.useRef(null)

  React.useEffect(() => {
    // üö® ref.current ser√° sempre ser√° null quando executado
    ref.current?.focus()
  }, [])

  return <Form ref={ref} />
}

const Form = React.forwardRef((props, ref) => {
  const [show, setShow] = React.useState(false)

  return (
    <form>
      <button type="button" onClick={() => setShow(true)}>
        show
      </button>
      // üßê ref esta anexado ao input, mas √© renderizado condicionalmente
      // ent√£o isso n√£o ser√° preenchido quando o effect acima for executar
      {show && <input ref={ref} />}
    </form>
  )
})
```
Aqui est√° o que acontece:

- Formul√°rio renderiza.
- _input_ n√£o √© renderizado, _ref_ continua _null_
- effect executa, nada acontece
- input √© mostrado, _ref_ ser√° preenchido mas n√£o ser√° focado porque o effect n√£o ser√° executado novamente.

O problema √© que o effect √© "vinculado" a fun√ß√£o renderiza√ß√£o do Formul√°rio, enquanto na verdade queremos que: "Foca o input quando ele for renderizado", n√£o "quando o formul√°rio √© montado".

## Callback refs
√â aqui que os callbacks refs entram in jogo. Se voc√™ j√° olhou para [declara√ß√µes de tipo para refs](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/fc9b16957473f81a1d708e6948b8d61e292aeb58/types/react/v17/index.d.ts#L85), podemos ver que podemos n√£o s√≥ passar um objeto ref para ele, mas tamb√©m uma fun√ß√£o:

```ts
type Ref<T> = RefCallback<T> | RefObject<T> | null
```
Conceitualmente eu gosto de pensar em refs em elementos do React como fun√ß√µes que s√£o chamadas depois que o componente √© renderizado. Est√° fun√ß√£o obtem o elemento DOM renderizado passado como argumento. Se o elemento React for desmonta ele ser√° chamado mais uma vez com _null_.
Passando um ref  _useRef_ (um RefObject) para um elemento React √©  _Syntactic Sugar_ (mam√£o com a√ßucar):

```jsx
<input
  ref={(node) => {
    ref.current = node;
  }}
  defaultValue="Hello world"
/>
```
Deixe-me enfatizar isso mais uma vez:
**Todas propriedades ref s√£o apenas fun√ß√µes!**

E essas fun√ß√µes executam depois da renderiza√ß√£o, aonde n√£o h√° problema executar efeitos colaterais. Talvez fosse melhor se o _ref_ fosse somente chamado _depoisDaRenderizacao_ ou algo assim.

Com esse conhecimento, o que n√≥s impede de de forcar o input dentro do callback ref, aonde temos acesso direto ao n√≥?

```jsx
<input
  ref={(node) => {
    node?.focus()
  }}
  defaultValue="Hello world"
/>
```
Bom, um pequeno detalhe: React ir√° executar essa fun√ß√£o ap√≥s _toda_ renderiza√ß√£o. Ent√£o, ao menos que estejamos bem em focar nosso input com tanta frequ√™ncia (o que, provavelmente, n√£o estamos), temos que dizer para o React somente executar isso somente quando quisermos. 

### useCallback para o resgate

Felizmente, o React usa estabilidade referencial para verificar se o callback ref deve ser executado ou n√£o. Isso significa que se passarmos o mesmo ref para ele, a execu√ß√£o ser√° ignorada.

E √© que entra o _useCallback_, porque √© assim que garantimos que a fun√ß√£o n√£o seja criada desnecessariamente. Talvez por isso que eles s√£o chamados de callback-refs - porque voc√™ tem que envolvelos em _useCallback_ o tempo todo.  üòÇ

Aqui est√° a solu√ß√£o final:

```jsx
const ref = React.useCallback((node) => {
  node?.focus()
}, [])

return <input ref={ref} defaultValue="Hello world" />
```

Comparando com a vers√£o inicial, √© menos c√≥digo e usa apenas um hook no lugar de dois, Al√©m disso, funcionar√° em todas situa√ß√µes, poque o callback ref est√° vinculado ao ciclo de vida do n√≥ DOM, n√£o do componente que o monta. Al√©m disso ele n√£o ser√° executado duas vezes no _strict mode_ (quando executado no ambiente de desenvolvimento) o que parece ser importante para muitos.

E como mostrado nessa [joia escondida na (antiga) documenta√ß√£o do React](https://pt-br.reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node), voc√™ pode usar isso para executar qualquer tipo de efeito colateral, ex. chamar _setState_ nele. Eu vou deixar um exemplo aqui poque na verdade √© muito bom:

```jsx
function MeasureExample() {
  const [height, setHeight] = React.useState(0)

  const measuredRef = React.useCallback(node => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height)
    }
  }, [])

  return (
    <>
      <h1 ref={measuredRef}>Hello, world</h1>
      <h2>The above header is {Math.round(height)}px tall</h2>
    </>
  )
}
```

Ent√£o por favor, se voc√™ precisa interagir com elementos DOM diretamente depois da renderiza√ß√£o, tente n√£o pular direto no _useRef_ + _useEffect_, mas considere usar _callback refs_ em vez disso.


> Original article in English can be read at [Avoiding useEffect with callback refs](https://tkdodo.eu/blog/avoiding-use-effect-with-callback-refs)